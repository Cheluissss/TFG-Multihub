% ==========================================================
% CAPÍTULO 3: SELECCIÓN TECNOLÓGICA
% ==========================================================
\chapter{Selección Tecnológica y Arquitectura}
\label{ch:tecnologia}

\section{Arquitectura del Sistema}

Para satisfacer los requisitos no funcionales de interactividad, inmediatez y escalabilidad, se ha diseñado una arquitectura basada en \textbf{Componentes} y fuertemente desacoplada. La solución sigue el patrón de separación de responsabilidades entre el \textit{Frontend} (Cliente) y el \textit{Backend} (Servidor), estableciendo la comunicación a través de una API RESTful estandarizada.

Esta separación arquitectónica ofrece múltiples ventajas:

\begin{itemize}
    \item \textbf{Claridad de responsabilidades:} Frontend gestiona UI/UX y estado local; Backend maneja lógica de negocio y persistencia.
    \item \textbf{Mantenibilidad mejorada:} Cambios en una capa no requieren refactorización de la otra, facilitando el desarrollo iterativo individual.
    \item \textbf{Testabilidad:} Cada capa puede ser testeada independientemente (unitarios, integración, E2E).
    \item \textbf{Escalabilidad futura:} Permite integración de nuevos clientes (aplicación móvil nativa, dashboards BI, integraciones POS) sin modificar la lógica de negocio central.
\end{itemize}

\subsection*{Flujo de Datos}

El flujo de comunicación entre capas es bidireccional y asíncrono:

\begin{enumerate}
    \item \textbf{Frontend (React):} Usuario interactúa con la UI. JavaScript captura eventos, valida inputs localmente con Zod, y prepara peticiones HTTP.
    \item \textbf{API REST (Express):} Recibe petición, valida esquema de nuevo con Zod, ejecuta lógica de negocio, consulta/actualiza datos en PostgreSQL vía Prisma.
    \item \textbf{Base de Datos (PostgreSQL):} Persiste datos con garantías ACID. Prisma genera SQL optimizado automáticamente.
    \item \textbf{Respuesta al Cliente:} JSON tipado se serializa y transmite al frontend. TanStack Query gestiona caché inteligentemente.
\end{enumerate}

\begin{figure}[h]
    \centering
    % Asegúrate de actualizar la imagen si el diagrama cambia, aunque la arquitectura base es la misma.
    \includegraphics[width=0.8\textwidth]{imagenes/React Client Architecture-2025-12-09-180737.png}
    \caption{Diagrama de alto nivel de la arquitectura Cliente-Servidor propuesta.}
    \label{fig:arquitectura}
\end{figure}

\section{Stack Tecnológico (PERN + TypeScript)}

La pila tecnológica seleccionada para la implementación se conoce en la industria como \textbf{PERN Stack} (PostgreSQL, Express, React, Node.js). Adicionalmente, se ha incorporado \textbf{TypeScript} de manera transversal en todo el proyecto para garantizar la seguridad de tipos y robustez del código.

A continuación, se detalla y justifica la elección de cada tecnología, contrastándola con alternativas descartadas.

\subsection{Frontend: Interfaz de Usuario}
El desarrollo de la interfaz de usuario prioriza la experiencia ``Mobile-First'' y la reactividad, requisitos esenciales para que empleados en diferentes sedes y roles (CEO, gerentes, empleados) puedan acceder desde múltiples dispositivos.

\begin{itemize}
    \item \textbf{React.js:} Biblioteca de JavaScript para la construcción de interfaces.
    \\ \textit{Justificación Comercial:} La reutilización de componentes es crítica para un equipo de desarrollo en solitario. Elementos como el ``Calendario de Turnos'', ``Panel de Notificaciones'' y ``Formularios de Turnos'' se utilizan repetidamente en diferentes contextos. Este enfoque reduce bugs y acelera time-to-market. Además, el éxito comprobado de React en aplicaciones empresariales como Facebook, Netflix e Instagram garantiza madurez y comunidad.
    \\ \textit{Justificación Técnica:} El modelo de componentes funcionales con hooks permite lógica clara y testeable. La arquitectura unidireccional de flujo de datos (props down, events up) previene bugs de estado común en aplicaciones complejas.

    \item \textbf{Vite:} Entorno de desarrollo y herramienta de construcción (bundler).
    \\ \textit{Justificación Comercial:} El ciclo de desarrollo es crítico en el Scrum. Vite reduce tiempos de recarga a <100ms vs 1-2s en Webpack, permitiendo feedback inmediato. Esto traduce a 2-3 horas productivas adicionales por semana de desarrollo, significativo en un proyecto de 6 sprints.
    \\ \textit{Justificación Técnica:} Uso de módulos ES6 nativos durante desarrollo elimina step de bundling, vs Webpack que requería transpilación. En producción, Vite genera bundles 30-40\% más pequeños con tree-shaking automático.
    
    \item \textbf{TanStack Query (React Query):} Gestor de estado asíncrono.
    \\ \textit{Justificación de Negocio:} La gestión manual de caché y state es la principal fuente de bugs frontend (datos desincronizados, pérdida de cambios, UX pobre). TanStack Query encapsula 80\% de la lógica asíncrona común, reduciendo bugs en desarrollo de features y acelerando entregas.
    \\ \textit{Justificación Técnica:} Mantiene dos fuentes de verdad sincronizadas automáticamente: estado local (UI) y estado servidor (DB). Background refetching detecta cambios en tiempo real; retry automático mejora resiliencia en redes débiles (crucial para empleados en tienda).

    \item \textbf{Tailwind CSS:} Framework de utilidades CSS.
    \\ \textit{Justificación de Negocio:} La consistencia visual entre sedes es importante para brand della PYME. Tailwind impone paleta de colores, espaciado y tipografía uniformes mediante configuración central, vs CSS custom que es propenso a inconsistencias. Reducción de time-to-design permite enfoque en lógica de negocio.
    \\ \textit{Justificación Técnica:} El enfoque ``utility-first'' genera CSS mucho más pequeño (purga automática de CSS no usado) que librerías CSS pesadas. Bundle CSS final: ~20kB vs 50+ con Bootstrap.

    \item \textbf{Day.js:} Librería de manipulación de fechas.
    \\ \textit{Justificación de Negocio:} Errores de fecha/hora frecuentemente causan reclamaciones de empleados (paga incorrecta). Una librería robusta con soporte de timezones previene bugs costosos. Day.js elegido por peso ultra-bajo (2kB vs Moment.js 67kB).
    \\ \textit{Justificación Técnica:} Inmutabilidad por diseño (cada operación retorna nuevo objeto) previene errores de mutación silenciosa comunes en JavaScript vanilla.
\end{itemize}

\subsection{Backend: Lógica de Negocio y API}
El servidor actúa como orquestador de la lógica de negocio, seguridad y acceso a datos. La selección de tecnologías backend prioriza confiabilidad (datos de nómina/contratos no pueden perderse), velocidad de iteración (desarrollador único), y escalabilidad futura.

\begin{itemize}
    \item \textbf{Node.js y Express.js:} Entorno de ejecución y framework web minimalista.
    \\ \textit{Justificación de Negocio:} Ecosistema JavaScript unificado frontend-backend permite que un único desarrollador sea productivo sin context-switching entre lenguajes. Express es el framework más usado en industria (comunidad, librerías, ejemplos), minimizando riesgo técnico.
    \\ \textit{Justificación Técnica:} El modelo de E/S no-bloqueante (event-driven) de Node.js es optimal para sistemas REST intensivos en I/O: cada petición es una operación asíncrona que no bloquea otras. Pueden manejarse miles de conexiones concurrentes con bajo overhead de memoria. Comparado con modelo thread-per-request de Java/C\#, Node.js requiere ~50MB/conexión vs ~1MB.

    \item \textbf{Zod:} Librería de validación de esquemas (Schema Validation).
    \\ \textit{Justificación de Negocio:} Errores de validación en transacciones económicas son críticos. Zod impone contract strict entre frontend y backend, detectando discrepancias en datos (ej: una nómina con campo de sueldo como string en lugar de number). El costo de un bug de validación desapercibido (sobrepagas, sueldos truncados) es exponencialmente mayor que invertir en validación exhaustiva.
    \\ \textit{Justificación Técnica:} Zod permite inferir tipos TypeScript directamente del esquema. Si cambio el schema, TypeScript me obliga a actualizar el código que consume (compiler catches breaking changes). Sin esto, cambios a la API pueden romper clientes sin saberlo hasta runtime.

    \item \textbf{JWT (JSON Web Tokens):} Estándar de autenticación.
    \\ \textit{Justificación de Negocio:} Autenticación stateless es requisito para escalar. Si guardo sesiones en memoria en el servidor, escalabilidad horizontal requeriría sincronización entre instancias (sticky sessions, shared cache). JWT elimina ese problema: cada petición es auto-suficiente. Perfectamente escalable. Además, JWT permite pre-autenticar via QR codes, RFID, biometría sin cambiar la API.
    \\ \textit{Justificación Técnica:} JWT contiene claims (UserID, rol) firmados criptográficamente. Servidor no necesita conexión a DB para validar; solo verifica firma. Reduce latencia de autenticación a <1ms vs 10-50ms de búsqueda en DB.
\end{itemize}

\subsection{Persistencia de Datos}
\begin{itemize}
    \item \textbf{PostgreSQL:} Sistema de gestión de bases de datos relacional (RDBMS).
    \\ \textit{Justificación de Negocio:} El sistema maneja datos financieros críticos: nóminas, contratos, distribución de ganancias por sede. La pérdida o corrupción de datos es inaceptable. PostgreSQL proporciona ACID (Atomicity, Consistency, Isolation, Durability), garantizando integridad incluso ante crashes. Además, soporte para foreign keys y constraints aseguran que la base de datos "rechace" operaciones inválidas (ej: no cree turno para empleado que no existe). También es open-source, evitando lock-in comercial.
    \\ \textit{Justificación Técnica:} PostgreSQL soporta transacciones complejas (ej: crear turno + decrementar cuota de horas en una operación atómica). Incluye índices sofisticados, JSON nativo, y Full-Text Search. Probado en miles de sistemas empresariales, de Twitter a Instagram.

    \item \textbf{Prisma ORM:} Herramienta de Mapeo Objeto-Relacional.
    \\ \textit{Justificación de Negocio:} SQL inyección es una de las vulnerabilidades más comunes y costosas. Prisma previene esto automáticamente via parameterized queries. También proporciona migraciones versionadas, permitiendo auditar cada cambio a la estructura de datos (crítico para compliance y debugging). En desarrollo, ``prisma studio'' permite visualizar datos sin escribir SQL, acelerando debugging.
    \\ \textit{Justificación Técnica:} Prisma genera TypeScript types automáticamente del schema. Si cambio la tabla User en PostgreSQL, ejecutar ``npx prisma generate'' actualiza tipos TypeScript. TypeScript compiler obliga a todos los \.ts files que usan User a adaptarse. Bugs de schema dormant son imposibles. Comparado con escritura manual de tipos o ORMs genéricos, reduce bugs de incompatibilidad 80\%.
\end{itemize}

\subsection{Herramientas de Soporte}

\begin{itemize}
    \item \textbf{Git y GitHub:} Control de versiones distribuido.
    \\ \textit{Justificación de Negocio:} Permite trazabilidad completa de cambios. Si ocurre un bug en producción (ej: empleados pagan 10\% menos de lo debido), puedo revisar exactamente qué código cambió en los últimos commits y revertir si es necesario. Además, GitHub Actions permite CI/CD: cada commit corre tests automáticamente, detectando bugs antes de que lleguen a producción.
    \\ \textit{Justificación Técnica:} Modelo distribuido permite que múltiples desarrolladores trabajen sin conflictos. Rama \texttt{main} protegida requiere que todo cambio pase tests y revisión antes de mergear (previene merges accidentales de código roto). Squash commits mantienen historia limpia pese a múltiples iteraciones locales.
    
    \item \textbf{ESLint y Prettier:} Linting y code formatting.
    \\ \textit{Justificación de Negocio:} Por cada issue de formato (inconsistencia de espacios, semicolons) que causa conflicto de merge, se pierde 15-30 minutos. Prettier elimina esto: formatea automáticamente en cada save, precommit-hooks evitan commits mal formateados. Tiempo ahorrado se invierte en features.
    \\ \textit{Justificación Técnica:} ESLint (Con preset airbnb-typescript) identifica bugs comunes (variables no usadas, tipos implícitos any, errores lógicos). Pre-commit hooks ejecutan automáticamente antes de que código llegue a repositorio, asegurando que main branch nunca contiene código que viola estándares.
\end{itemize}

\section{Estrategia de Testing}

La calidad de código es crítica en sistemas que manejan datos empresariales sensibles. Se implementa una estrategia de testing en tres niveles:

\begin{itemize}
    \item \textbf{Unit Tests (Jest):} Testeado en backend para funciones puras: cálculo de horas, validación de turnos, lógica de permisos RBAC. Target: 80\% de cobertura en módulos críticos.
    
    \item \textbf{Integration Tests (Supertest + Jest):} Validación de flujos API completos: crear usuario → asignar rol → consultar datos desde cliente. Incluye mock de PostgreSQL con test containers.
    
    \item \textbf{E2E Tests (Playwright):} Casos de uso completos desde UI: login CEO → acceder dashboard → filtrar por sede. Tests en navegador real (Chrome, Firefox).
\end{itemize}

\textbf{Ejecución:} Scripts en \texttt{package.json}: \texttt{npm run test}, \texttt{npm run test:e2e}. Integración con CI/CD para rechazar PR si tests fallan.

\section{Seguridad y Control de Acceso}

La seguridad es multinivel y se refuerza en cada capa:

\begin{itemize}
    \item \textbf{Autenticación (JWT):} 
    \begin{itemize}
        \item Access Token válido 15 minutos (minimiza exposición si es robado).
        \item Refresh Token válido 7 días, almacenado en HTTP-only cookie (protegido de XSS).
        \item Backend valida firma JWT en cada petición; rechaza si expirado o inválido.
    \end{itemize}
    
    \item \textbf{Autorización (RBAC):}
    \begin{itemize}
        \item Tres roles: \texttt{ADMIN} (CEO), \texttt{MANAGER} (Gerente), \texttt{EMPLOYEE} (Empleado).
        \item Middleware Express valida permisos antes de ejecutar lógica: \texttt{(req, res, next) => checkRole(req.user.role, REQUIRED\_ROLES)}.
        \item Filtrado de datos en queries: empleado solo ve sus turnos y nómina, gerente solo su sede.
    \end{itemize}
    
    \item \textbf{Validación en Frontend y Backend:}
    \begin{itemize}
        \item Frontend valida con Zod para UX rápido.
        \item Backend valida de nuevo por seguridad (nunca confiar en cliente).
    \end{itemize}
    
    \item \textbf{Protección de Datos Sensibles:}
    \begin{itemize}
        \item Nóminas y contratos se transmiten por HTTPS (TLS 1.2+).
        \item Contraseñas hasheadas con bcrypt (10 rounds) en DB.
        \item SQL injection prevenida por Prisma (parameterized queries).
    \end{itemize}
\end{itemize}

\section{Performance y Escalabilidad}

Optimizaciones implementadas para garantizar responsividad incluso al crecer:

\begin{itemize}
    \item \textbf{Frontend:}
    \begin{itemize}
        \item Code splitting: cada ruta carga solo su JS (lazy loading con React.lazy).
        \item Caché inteligente con TanStack Query: evita fetches innecesarios.
        \item Compression gzip en dist (Vite).
        \item Imágenes optimizadas (webp, srcset responsivo).
    \end{itemize}
    
    \item \textbf{Backend:}
    \begin{itemize}
        \item Índices PostgreSQL en columnas frequently queried: usuario\_id, sede\_id, fecha.
        \item Paging en listados (no traer 10K turnos sin paginar).
        \item Compression HTTP (gzip) de respuestas JSON grandes.
        \item Connection pooling con Prisma para no agotarBD.
    \end{itemize}
    
    \item \textbf{Infraestructura:}
    \begin{itemize}
        \item Docker containers permiten scaling horizontal (múltiples instancias del backend).
        \item Load balancer (nginx o AWS ALB) distribuye peticiones.
    \end{itemize}
\end{itemize}

\section{Deployment y DevOps}

Configuración para producción:

\begin{itemize}
    \item \textbf{Containerización:} Dockerfile para backend (Node.js image alpine, <100MB). Frontend buildado a static files (HTML/CSS/JS), servido por nginx.
    
    \item \textbf{Base de Datos:} PostgreSQL en container separado (volumen persistente) o servicio managed (AWS RDS). Backups automáticos diarios.
    
    \item \textbf{Entornos:}
    \begin{itemize}
        \item \texttt{Development:} localhost:3000 (frontend), localhost:3001 (backend). Database local.
        \item \texttt{Production:} Docker Compose o Kubernetes. Variables de entorno para credenciales (no hardcodeadas).
    \end{itemize}
    
    \item \textbf{Monitoreo:} Logs centralizados (stdout/stderr capturados por Docker). Alertas si API no responde.
\end{itemize}

\section{Análisis Comparativo: Alternativas Descartadas}

La Tabla \ref{tab:tech_comparison} justifica por qué se seleccionó PERN+TS sobre otras opciones del mercado.

\begin{table}[h]
    \centering
    \caption{Comparativa de stacks tecnológicos: razones de selección PERN}
    \label{tab:tech_comparison}
    \vspace{0.3cm}
    \small
    \setlength{\tabcolsep}{4pt}
    \renewcommand{\arraystretch}{1.2}
    \begin{tabularx}{\textwidth}{>
        {\raggedright\arraybackslash}p{0.22\textwidth}
        >{\raggedright\arraybackslash}p{0.26\textwidth}
        X}
        \toprule
        \textbf{Stack} & \textbf{Ventajas} & \textbf{Limitaciones / Razones de rechazo} \\
        \midrule
        \textbf{PERN + TypeScript} & Community grande, open-source, flexible, mobile-first facil, ACID DB, testing sencillo & Ninguno para este proyecto. Seleccionado. \\
        \addlinespace
        \textbf{MEAN/MERN (MongoDB)} & Schema flexible, rapido para prototipo & MongoDB pierde ACID en collections distribuidas. Para datos criticos (nominas) se requiere integridad. \\
        \addlinespace
        \textbf{Next.js (SSR fullstack)} & Menos boilerplate, SSR de serie & Next.js mezcla backend/frontend. Dificulta testing aislado. Overkill para esta SPA. \\
        \addlinespace
        \textbf{.NET + Azure} & Enterprise-grade, MSSQL robusto & Licenciado y costoso. Overkill para PYME. Menos community para features innovadores. \\
        \addlinespace
        \textbf{Django + PostgreSQL} & DRF excelente, admin built-in & Python frontend debil (no hay equivalente a React). Habria que usar React + Django API, similar a PERN pero con menos integraciones. \\
        \addlinespace
        \textbf{Java Spring + React} & Spring Boot robusto, mature & Verboso, lento de desarrollar en solitario. Overhead de JVM. Mejor para teams grandes. \\
        \bottomrule
    \end{tabularx}
\end{table}
