% ==========================================================
% CAPÍTULO 5: PLAN DE DESARROLLO ÁGIL Y DIVISIÓN DE TAREAS
% ==========================================================
\chapter{Plan de Desarrollo Ágil}
\label{ch:desarrollo}

\section{Metodología de Desarrollo}

El proyecto se desarrolla bajo \textbf{metodología Scrum adaptada} con ciclos iterativos de 2 semanas.

\subsection*{Parámetros del Proyecto}

\begin{itemize}
    \item \textbf{Duración Total:} 12 semanas (febrero 9 - mayo 4, 2026)
    \item \textbf{Dedicación:} 15 horas/semana (promedio)
    \item \textbf{Total de Horas Disponibles:} 180 horas
    \item \textbf{Número de Sprints:} 6 sprints de 2 semanas
    \item \textbf{Horas/Sprint:} ~30 horas (2 sprints paralelos = 60h/mes)
\end{itemize}

\section{Product Backlog Priorizado}

El Product Backlog contiene todas las funcionalidades organizadas por prioridad, estimadas en \textbf{Story Points}.


\subsection*{Grupo 1: Infraestructura y Seguridad (CRÍTICO - Sprint 1-2)}

\begin{table}[h]
    \centering
    \caption{Backlog: Infraestructura}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-1 & Setup: git, ESLint, Prettier, carpetas & 3 & ALTA \\
        PBI-2 & PostgreSQL + schema inicial (User, Sede, Shift) & 3 & ALTA \\
        PBI-3 & Express: servidor, middleware, CORS & 2 & ALTA \\
        PBI-4 & React + Vite + Tailwind + componentes base & 3 & ALTA \\
        PBI-5 & JWT: access/refresh tokens + logout & 5 & ALTA \\
        PBI-6 & Endpoint /auth/login + validaciones & 3 & ALTA \\
        PBI-7 & Pantalla Login (frontend) & 3 & ALTA \\
        PBI-8 & RBAC middleware (CEO/Manager/Employee) & 5 & ALTA \\
        PBI-9 & Endpoint /auth/register (solo admin) & 2 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 2: Gestión de Usuarios (Sprint 2-3)}

\begin{table}[h]
    \centering
    \caption{Backlog: Usuarios y Sedes}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-10 & Endpoints CRUD usuarios (GET/POST/PUT/DELETE) & 5 & ALTA \\
        PBI-11 & Endpoints CRUD sedes & 3 & ALTA \\
        PBI-12 & Validaciones Zod (usuario, sede) & 2 & ALTA \\
        PBI-13 & Pantalla Admin: Crear usuario + asignar rol/sede & 5 & ALTA \\
        PBI-14 & Pantalla Admin: Listar usuarios, filtrar, editar & 5 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 3: Dashboard CEO (Sprint 3-4)}

\begin{table}[h]
    \centering
    \caption{Backlog: Dashboard Ejecutivo}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-15 & Endpoint GET /dashboard/metrics (ventas, ocupación, stock) & 8 & ALTA \\
        PBI-16 & Pantalla Dashboard: layout KPIs básico & 5 & ALTA \\
        PBI-17 & Gráficas Recharts (líneas, barras, tablas) & 5 & MEDIA \\
        PBI-18 & TanStack Query: caché de datos en frontend & 3 & MEDIA \\
        PBI-19 & Filtros por fecha y sede & 3 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 4: Gestión de Turnos (Sprint 3-5) - CORE}

\begin{table}[h]
    \centering
    \caption{Backlog: Turnos}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-20 & Endpoints CRUD turnos (crear, listar, cancelar) & 8 & ALTA \\
        PBI-21 & Validación overlaps + unit tests & 5 & ALTA \\
        PBI-22 & Endpoint confirmar turno (empleado) & 3 & ALTA \\
        PBI-23 & Calendario Gerente: semanal + crear turno & 8 & ALTA \\
        PBI-24 & Calendario Empleado: semanal/mensual & 5 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 5: Permutas de Turnos (Sprint 5)}

\begin{table}[h]
    \centering
    \caption{Backlog: Solicitudes de Permuta}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-25 & Endpoint crear/listar ShiftRequest & 5 & MEDIA \\
        PBI-26 & Endpoint aprobar/rechazar permuta & 5 & MEDIA \\
        PBI-27 & Pantalla Gerente: Centro de Notificaciones & 5 & MEDIA \\
        PBI-28 & Pantalla Empleado: Solicitar permuta & 5 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 6: Inventario (Sprint 5-6)}

\begin{table}[h]
    \centering
    \caption{Backlog: Gestión de Productos}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-29 & Endpoints CRUD productos (crear, editar, listar) & 5 & MEDIA \\
        PBI-30 & Endpoint ajustar stock + log cambios & 5 & MEDIA \\
        PBI-31 & Alertas bajo stock (lógica backend) & 2 & MEDIA \\
        PBI-32 & Pantalla Gerente: Catálogo productos & 5 & MEDIA \\
        PBI-33 & Pantalla Gerente: Ajustar stock & 3 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 7: Nóminas (Sprint 6 - OPCIONAL)}

\begin{table}[h]
    \centering
    \caption{Backlog: Gestión de Nóminas}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-34 & Endpoint subir PDF nómina (validación básica) & 5 & BAJA \\
        PBI-35 & Endpoint listar nóminas empleado & 2 & BAJA \\
        PBI-36 & Pantalla Gerente: Subir nóminas & 3 & BAJA \\
        PBI-37 & Pantalla Empleado: Mis nóminas + descarga & 3 & BAJA \\
        \bottomrule
    \end{tabularx}
\end{table}


\subsection*{Grupo 8: Feedback y Testing (Sprint 6 - OPCIONAL)}

\begin{table}[h]
    \centering
    \caption{Backlog: Feedback y Testing}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-38 & Endpoint feedback (crear, listar, cambiar estado) & 5 & BAJA \\
        PBI-39 & Pantalla Empleado: Formulario feedback & 2 & BAJA \\
        PBI-40 & Pantalla CEO: Tablero feedback & 3 & BAJA \\
        PBI-41 & Unit tests: 50+ tests, 80\% cobertura & 13 & BAJA \\
        PBI-42 & Integration tests: 5+ flujos críticos & 8 & BAJA \\
        \bottomrule
    \end{tabularx}
\end{table}

\section{Planificación de Sprints (6 x 2 semanas)}

\subsection*{Sprint 1 (Feb 9-22): Infraestructura y Autenticación}
\textbf{PBIs:} 1-9 (28 SP) \textbf{COMPLETADO}

El Sprint 1 constituye la fase fundamental del proyecto, estableciendo los cimientos arquitectónicos y sistemas de autenticación requeridos para el funcionamiento seguro de la aplicación. Este sprint se centró en la implementación de una infraestructura robusta que cumpliera con estándares industry e implementara buenas prácticas de seguridad.

\subsubsection*{PBI-1: Setup (git, ESLint, Prettier)}

La inicialización del proyecto mediante control de versiones y definición de estándares de código es esencial para garantizar la mantenibilidad y colaboración eficiente \cite{typescript_docs}. Se realizó la configuración de:

\begin{itemize}
    \item \textbf{Gestor de Control de Versiones:} Repositorio Git en GitHub (TFG-Multihub) para tracking de cambios y colaboración
    \item \textbf{Linting:} ESLint con configuración \textit{airbnb-typescript} para mantener consistencia de código y prevenir errores comunes
    \item \textbf{Formateo:} Prettier configurado para garantizar formato automático coherente en todo el codebase
    \item \textbf{Estructura Monorepo:} Directorios separados para \texttt{/backend} y \texttt{/frontend} permitiendo gestión independiente de dependencias
\end{itemize}

\subsubsection*{PBI-2: PostgreSQL + Schema de Base de Datos}

El diseño relacional del sistema requería una base de datos que proporcionara ACID compliance y transaccionalidad robusta. Se seleccionó PostgreSQL 16 como motor de almacenamiento, complementado con Prisma ORM \cite{prisma_docs} para abstracción de datos tipada en TypeScript.

El schema relacional implementado define los siguientes modelos de datos:

\begin{itemize}
    \item \textbf{User}: Entidad representante de usuarios del sistema con campos de autenticación, identificación y asignación de roles (ADMIN, MANAGER, EMPLOYEE)
    \item \textbf{Sede}: Entidades de oficinas con información de localización, contacto y manager responsable
    \item \textbf{Shift}: Entidades de turnos laborales con validación de no-solapamiento mediante restricciones de base de datos
    \item \textbf{ShiftRequest}: Transacciones de solicitud de permuta entre empleados con workflow de aprobación
\end{itemize}

Ejemplo del schema en Prisma:
\begin{lstlisting}[language=typescript]
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  name      String
  role      UserRole
  sedeId    String?
  createdAt DateTime @default(now())
  // ... relaciones y timestamps ...
}

enum UserRole {
  ADMIN
  MANAGER
  EMPLOYEE
}

model Shift {
  id       String   @id @default(cuid())
  type     ShiftType
  date     DateTime
  startTime String
  endTime  String
  // Restricción única para prevenir overlaps
  @@unique([date, type, employeeId, sedeId])
}
\end{lstlisting}

Justificación: El uso de Prisma ORM proporciona type-safety en tiempo de compilación, migraciones versionadas, y validaciones a nivel de schema. PostgreSQL fue seleccionado por su fiabilidad comprobada en entornos empresariales \cite{postgresql_docs} y soporte nativo de tipos de datos avanzados.

\subsubsection*{PBI-3: Express.js + Middleware}

El backend fue implementado usando Express.js \cite{express_docs}, framework minimalista pero robusto de Node.js. La configuración incluyó:

\begin{itemize}
    \item \textbf{Middleware CORS:} Configuración enabling credenciales para intercambio seguro de tokens JWT y cookies \cite{cors_mdn}
    \item \textbf{Body Parser:} Middleware para parseado automático de payloads JSON
    \item \textbf{Error Handling:} Middleware global para captura y normalización de errores
    \item \textbf{Health Check:} Endpoint de diagnosticidad en \texttt{GET /health} para monitoreo de infraestructura
\end{itemize}

La configuración de CORS fue específicamente diseñada para permitir credenciales, prerequisito esencial para validación de refresh tokens en httpOnly cookies:

\begin{lstlisting}[language=typescript]
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));
\end{lstlisting}

Justificación: La habilitación de credenciales es crítica en arquitecturas que utilizan httpOnly cookies para almacenar refresh tokens, previniendo exposición a ataques XSS al no permitir acceso vía JavaScript \cite{cors_mdn}.

\subsubsection*{PBI-4: React + Vite + Tailwind}

El frontend fue construido con stack moderno basado en React 18 \cite{react_docs}, optimizando para desarrollo rápido y compilación eficiente:

\begin{itemize}
    \item \textbf{Bundler:} Vite para compilación ultra-rápida con HMR (Hot Module Replacement)
    \item \textbf{Estilos:} Tailwind CSS para componentes styled-components basados en utilidades
    \item \textbf{Navegación:} React Router para SPA con rutas públicas y protegidas
    \item \textbf{Gestión de Datos:} TanStack Query para caching y sincronización con servidor
    \item \textbf{Tipado:} TypeScript strict mode para máxima seguridad de tipos \cite{typescript_docs}
\end{itemize}

Justificación: La selección de Vite sobre Webpack proporciona tiempos de dev server 10-100x más rápidos, mejorando significativamente la experiencia de desarrollo. TypeScript en strict mode captura errores en compile-time que de otro modo se manifestarían en runtime.

\subsubsection*{PBI-5: JSON Web Tokens (JWT) - Tokens de Acceso y Refresca}

El sistema de autenticación fue implementado siguiendo el estándar RFC 7519 \cite{rfc7519} para JSON Web Tokens. La arquitectura utiliza un modelo de dos tokens para equilibrar seguridad con usabilidad:

\begin{itemize}
    \item \textbf{Access Token}: Duración 15 minutos. Utilizado para autenticación de requests API. Su corta duración limita exposición en caso de compromise.
    \item \textbf{Refresh Token}: Duración 7 días. Almacenado en httpOnly cookie para prevención de ataques XSS. Requerido para obtención de nuevos access tokens.
\end{itemize}

Las contraseñas de usuario son hasheadas usando bcryptjs \cite{bcryptjs_docs} con cost factor de 10 rounds, proporcionando resistencia computacional contra ataques de fuerza bruta.

Implementación de generación de tokens:

\begin{lstlisting}[language=typescript]
export function generateTokens(
  userId: string, 
  email: string, 
  role: string
) {
  const accessToken = jwt.sign(
    { userId, email, role },
    process.env.JWT_SECRET!,
    { expiresIn: '15m' }
  );

  const refreshToken = jwt.sign(
    { userId, email, role },
    process.env.JWT_REFRESH_SECRET!,
    { expiresIn: '7d' }
  );

  return { accessToken, refreshToken };
}
\end{lstlisting}

Middleware de validación y extracción de claims:

\begin{lstlisting}[language=typescript]
export const authMiddleware = (
  req: Request, 
  res: Response, 
  next: NextFunction
) => {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const payload = jwt.verify(token, process.env.JWT_SECRET!);
    req.user = payload;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};
\end{lstlisting}

Justificación: El modelo de dos tokens es recomendación estándar en OAuth 2.0 \cite{oauth2_rfc} para aplicaciones modernas, balanceando seguridad (access token corto) con experiencia de usuario (refresh token permite sesiones largas sin re-login). El almacenamiento de refresh tokens en httpOnly cookies previene acceso vía JavaScript, mitigando XSS attacks.

\subsubsection*{PBI-6: Endpoint /auth/login}

El endpoint de autenticación implementa flujo de validación de credenciales con las siguientes etapas:

\begin{lstlisting}[language=typescript]
async login(credentials: LoginRequest): Promise<LoginResponse> {
  // Validación de esquema usando Zod
  const validated = LoginSchema.parse(credentials);
  
  // Búsqueda de usuario por email
  const user = await prisma.user.findUnique({
    where: { email: validated.email },
  });

  if (!user) {
    throw new Error('Usuario o contraseña incorrectos');
  }

  // Comparación hasheada de contraseña (previene timing attacks)
  const passwordMatch = await bcryptjs.compare(
    validated.password, 
    user.password
  );

  if (!passwordMatch) {
    throw new Error('Usuario o contraseña incorrectos');
  }

  // Generación de JWT tokens
  const tokens = generateTokens(user.id, user.email, user.role);
  
  return {
    user: this.excludePassword(user),
    tokens,
  };
}
\end{lstlisting}

Características de seguridad implementadas:
\begin{itemize}
    \item \textbf{Constant-time Comparison}: Uso de \texttt{bcryptjs.compare()} previene timing attacks
    \item \textbf{Mensajes de Error Genéricos}: No se especifica si el email existe, previniendo enumeración de usuarios
    \item \textbf{Exclusión de Contraseña}: La contraseña nunca es retornada al cliente
\end{itemize}

\subsubsection*{PBI-7: Componente de Login (Frontend)}

El componente de autenticación frontend implementa un formulario con validaciones en tiempo real y gestión de estado:

\begin{lstlisting}[language=typescript]
export const AuthProvider: React.FC<{ children: React.ReactNode }> = 
({ children }) => {
  const [user, setUser] = useState<User | null>(getStoredUser());
  const [isLoading, setIsLoading] = useState(false);

  const login = async (credentials: LoginRequest): Promise<void> => {
    setIsLoading(true);
    try {
      const response = await authAPI.login(credentials);
      setAccessToken(response.data.tokens.accessToken);
      setStoredUser(response.data.user);
      setUser(response.data.user);
    } finally {
      setIsLoading(false);
    }
  };

  const contextValue: AuthContextType = {
    user,
    isAuthenticated: !!user && !!getAccessToken(),
    isLoading,
    login,
    logout,
    refreshTokens,
  };

  return React.createElement(
    AuthContext.Provider, 
    { value: contextValue }, 
    children
  );
};
\end{lstlisting}

Almacenamiento asimétrico de tokens:

\begin{lstlisting}[language=typescript]
// Access token: localStorage (necesario para headers de API)
export const getAccessToken = (): string | null => {
  return localStorage.getItem('accessToken');
};

// Refresh token: httpOnly cookie (gestionada por navegador)
// No es accesible desde JavaScript, previniendo XSS
\end{lstlisting}

Justificación: La separación de almacenamiento aprovecha los mecanismos nativos de seguridad del navegador. El localStorage permite acceso para configurar headers de Authorization, mientras que httpOnly cookies asegura que el refresh token no sea expuesto a ataques XSS.

\subsubsection*{PBI-8: Control de Acceso Basado en Roles (RBAC)}

La implementación de RBAC sigue estándares de seguridad definidos por NIST \cite{rbac_nist}. El middleware de validación de roles protege endpoints específicos:

\begin{lstlisting}[language=typescript]
export const roleMiddleware = (allowedRoles: UserRole[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ 
        error: 'Acceso denegado - permisos insuficientes' 
      });
    }
    next();
  };
};
\end{lstlisting}

Ejemplo de uso en rutas protegidas por rol:

\begin{lstlisting}[language=typescript]
// Solo ADMIN puede crear usuarios
router.post('/register', 
  authMiddleware,                    // Validar autenticación
  roleMiddleware(['ADMIN']),         // Validar rol
  asyncHandler((req, res) => authController.register(req, res))
);

// ADMIN y MANAGER pueden listar usuarios
router.get('/users',
  authMiddleware,
  roleMiddleware(['ADMIN', 'MANAGER']),
  asyncHandler((req, res) => authController.listUsers(req, res))
);
\end{lstlisting}

Justificación: El modelo de RBAC centraliza lógica de autorización, facilitando auditoría y modificación de políticas de acceso. La verificación tanto de presencia del usuario como de validez del rol proviene del JWT payload, asegurando inmutabilidad de claims.

\subsubsection*{PBI-9: Endpoint /auth/register - Creación de Usuarios}

El endpoint de registro implementa un flujo controlado donde únicamente administradores crean usuarios:

\begin{lstlisting}[language=typescript]
async register(
  data: RegisterRequest,
  adminId: string
): Promise<{ user: User; tempPassword: string }> {
  // Validación de entrada
  const validated = RegisterSchema.parse(data);
  
  // Verificación de existencia previa
  const existingUser = await prisma.user.findUnique({
    where: { email: validated.email },
  });
  
  if (existingUser) {
    throw new Error('El email ya está registrado');
  }

  // Generación de contraseña temporal (10 caracteres aleatorios)
  const tempPassword = this.generateTempPassword();
  const hashedPassword = await bcryptjs.hash(tempPassword, 10);

  // Creación de usuario
  const newUser = await prisma.user.create({
    data: {
      email: validated.email,
      name: validated.name,
      password: hashedPassword,
      role: validated.role as UserRole,
      sedeId: validated.sedeId,
    },
  });

  // Log de auditoría
  await this.logAdminAction(adminId, 'USER_CREATED', newUser.id);

  return {
    user: this.excludePassword(newUser),
    tempPassword,
  };
}
\end{lstlisting}

Esquemas de validación con Zod \cite{zod_docs}:

\begin{lstlisting}[language=typescript]
export const LoginSchema = z.object({
  email: z.string()
    .email('Email inválido')
    .transform(e => e.toLowerCase().trim()),
  password: z.string()
    .min(6, 'Contraseña mínimo 6 caracteres'),
});

export const RegisterSchema = z.object({
  email: z.string()
    .email('Email inválido')
    .transform(e => e.toLowerCase().trim()),
  name: z.string()
    .min(2, 'Nombre requerido')
    .max(100, 'Nombre demasiado largo'),
  role: z.enum(['ADMIN', 'MANAGER', 'EMPLOYEE'])
    .default('EMPLOYEE'),
  sedeId: z.string().uuid('ID de sede inválido').optional(),
});
\end{lstlisting}

Justificación: La generación de contraseña temporal por el sistema previene debilidad de contraseñas iniciales mientras mantiene control administrativo. Al obligar cambio de contraseña en primer acceso, se garantiza que solo el usuario conoce su credencial de acceso. Zod proporciona validación declarativa con type inference automático en TypeScript.

\subsubsection*{Componente ProtectedRoute - Rutas Protegidas (Frontend)}

La implementación de rutas protegidas en el frontend enforza políticas de autorización a nivel de UI, reduciendo exposición accidental de interfaces restringidas:

\begin{lstlisting}[language=typescript]
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: UserRole[];
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRoles 
}) => {
  const { user, isAuthenticated } = useAuth();

  // Redirección a login si no hay sesión activa
  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  // Validación de rol (si se especifican roles requeridos)
  if (requiredRoles && !requiredRoles.includes(user?.role!)) {
    return (
      <div className="p-4 bg-red-50 border border-red-200">
        Acceso denegado - permisos insuficientes
      </div>
    );
  }

  return <>{children}</>;
};
\end{lstlisting}

Configuración de React Router \cite{react_docs}:

\begin{lstlisting}[language=typescript]
const AppRouter = () => {
  return (
    <BrowserRouter>
      <Routes>
        {/* Rutas públicas */}
        <Route path="/login" element={<Login />} />
        
        {/* Rutas protegidas - acceso general */}
        <Route 
          path="/dashboard" 
          element={
            <ProtectedRoute>
              <Dashboard />
            </ProtectedRoute>
          } 
        />
        
        {/* Rutas protegidas - solo ADMIN */}
        <Route 
          path="/admin" 
          element={
            <ProtectedRoute requiredRoles={['ADMIN']}>
              <AdminPanel />
            </ProtectedRoute>
          } 
        />
      </Routes>
    </BrowserRouter>
  );
};
\end{lstlisting}

Justificación: La verificación de autenticación en ProtectedRoute proporciona una capa de seguridad adicional a nivel de UI. Aunque la seguridad primaria debe residir en el backend (validación de JWT), esta capa previene exposición accidental de interfaces y mejora experiencia de usuario al redirigir usuarios no autenticados.

\subsubsection*{Resumen Técnico Sprint 1}

El Sprint 1 estableció una base arquitectónica sólida basada en prácticas de seguridad reconocidas. La tabla \ref{tab:sprint1-tech-summary} resume tecnologías y patrones implementados:

\begin{table}[h]
    \centering
    \caption{Sprint 1 - Resumen de Arquitectura Técnica}
    \label{tab:sprint1-tech-summary}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l X}
        \toprule
        \textbf{Componente} & \textbf{Especificación} \\
        \midrule
        Stack Backend & Node.js 20 + Express.js \cite{express_docs} + TypeScript \cite{typescript_docs} \\
        Base de Datos & PostgreSQL 16 \cite{postgresql_docs} + Prisma ORM \cite{prisma_docs} \\
        Autenticación & JWT (RFC 7519) \cite{rfc7519} con access/refresh tokens \\
        Hash de Contraseña & bcryptjs \cite{bcryptjs_docs} con cost factor 10 \\
        Validación de Entrada & Zod \cite{zod_docs} con type inference TypeScript \\
        Stack Frontend & React 18 \cite{react_docs} + Vite + Tailwind CSS \\
        Gestión de Rutas & React Router con protección por rol \\
        Seguridad CORS & Configuración con credenciales habilitadas \cite{cors_mdn} \\
        RBAC & Implementación según estándares NIST \cite{rbac_nist} \\
        DevOps & Docker \cite{docker_docs} + GitHub Actions CI/CD \\
        Control de Versiones & Git + GitHub (TFG-Multihub) \\
        Linting/Formatting & ESLint (airbnb-typescript) + Prettier \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsubsection*{Resultados y Validación Sprint 1}

La completitud del Sprint 1 fue validada mediante:

\begin{itemize}
    \item \textbf{Pruebas Funcionales}: Endpoint \texttt{/api/auth/login} responde correctamente con JWT tokens válidos y user data
    \item \textbf{Verificación de Seguridad}: Validación de httpOnly cookies para refresh tokens y CORS configuration correcta
    \item \textbf{Cobertura de Tipado}: TypeScript strict mode sin errores de compilación en frontend y backend
    \item \textbf{Infraestructura}: Docker Compose services (PostgreSQL, Backend, Frontend) todos operacionales
    \item \textbf{Datos de Prueba}: Database seeded con usuarios de prueba en todos los roles (ADMIN, MANAGER, EMPLOYEE)
    \item \textbf{Endpoints API}: 7 endpoints de autenticación completamente funcionales
\end{itemize}

\textbf{Flujo de autenticación end-to-end validado:}
\begin{enumerate}
    \item Usuario navega a \texttt{http://localhost:3000/login}
    \item Ingresa credenciales que son validadas por esquema Zod contra restricciones definidas
    \item Submit realiza POST request hacia \texttt{/api/auth/login} con credenciales JSON
    \item Backend localiza usuario por email en PostgreSQL y valida contraseña contra hash bcryptjs
    \item JWT tokens generados con claims (userId, email, role) y expiración configurada
    \item Access token retornado en respuesta JSON; refresh token en httpOnly cookie
    \item Frontend almacena accessToken en localStorage para futuras requests API
    \item User automáticamente redirigido a dashboard con sesión activa y user info en contexto
    \item Logs de auditoría registran acceso exitoso (timestamp, IP, user agent)
    \item Logout limpia localStorage y elimina refresh cookie vía Set-Cookie header
    \item Subsequent requests usan accessToken en Authorization header (Bearer scheme)
\end{enumerate}

\subsubsection*{Decisiones de Arquitectura Fundamentales}

Las decisiones técnicas en Sprint 1 fueron justificadas por:

\begin{itemize}
    \item \textbf{JWT sobre Session Storage}: Stateless authentication facilita escalabilidad horizontal en microservicios futuros \cite{rfc7519}
    \item \textbf{Dual Token Strategy}: Access tokens cortos (15m) reduce ventana de riesgo; refresh tokens largos (7d) mantienen UX
    \item \textbf{httpOnly Cookies}: Previene XSS attacks eliminando acceso JavaScript a refresh tokens críticos
    \item \textbf{Contrast-time Password Comparison}: Uso de bcryptjs.compare() previene timing attacks en validación de credenciales
    \item \textbf{Role-Based Access Control}: Implementación granular permite asignación flexible de permisos con política centralizada
    \item \textbf{TypeScript Strict Mode}: Elimina categorías enteras de bugs comunes (null/undefined, implicit any types)
    \item \textbf{Prisma ORM}: Schema como source of truth; migraciones versionadas permiten auditoría histórica de cambios DB
\end{itemize}

\subsection*{Sprint 2 (Feb 23-Mar 8): RBAC y Gestión de Usuarios}
\textbf{PBIs:} 8-14 (30 SP)

\subsection*{Sprint 3 (Mar 9-22): Gestión de Turnos}
\textbf{PBIs:} 20-24 (28 SP)

\subsection*{Sprint 4 (Mar 23-Apr 5): Dashboard CEO}
\textbf{PBIs:} 15-19 (26 SP)

\subsection*{Sprint 5 (Apr 6-19): Permutas + Inventario}
\textbf{PBIs:} 25-33 (30 SP)

\subsection*{Sprint 6 (Apr 20-May 4): Nóminas, Feedback y Testing}
\textbf{PBIs:} 34-42 (30 SP)

