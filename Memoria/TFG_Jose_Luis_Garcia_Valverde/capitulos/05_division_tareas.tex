% ==========================================================
% CAPÍTULO 5: PLAN DE DESARROLLO ÁGIL Y DIVISIÓN DE TAREAS
% ==========================================================
\chapter{Plan de Desarrollo Ágil}
\label{ch:desarrollo}

\section{Metodología de Desarrollo}

El proyecto se desarrolla bajo \textbf{metodología Scrum adaptada} con ciclos iterativos de 2 semanas.

\subsection*{Parámetros del Proyecto}

\begin{itemize}
    \item \textbf{Duración Total:} 12 semanas (febrero 9 - mayo 4, 2026)
    \item \textbf{Dedicación:} 15 horas/semana (promedio)
    \item \textbf{Total de Horas Disponibles:} 180 horas
    \item \textbf{Número de Sprints:} 6 sprints de 2 semanas
    \item \textbf{Horas/Sprint:} ~30 horas (2 sprints paralelos = 60h/mes)
\end{itemize}

\section{Product Backlog Priorizado}

El Product Backlog contiene todas las funcionalidades organizadas por prioridad, estimadas en \textbf{Story Points}.


\subsection*{Grupo 1: Infraestructura y Seguridad (CRÍTICO - Sprint 1-2)}

\begin{table}[h]
    \centering
    \caption{Backlog: Infraestructura}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-1 & Setup: git, ESLint, Prettier, carpetas & 3 & ALTA \\
        PBI-2 & PostgreSQL + schema inicial (User, Sede, Shift) & 3 & ALTA \\
        PBI-3 & Express: servidor, middleware, CORS & 2 & ALTA \\
        PBI-4 & React + Vite + Tailwind + componentes base & 3 & ALTA \\
        PBI-5 & JWT: access/refresh tokens + logout & 5 & ALTA \\
        PBI-6 & Endpoint /auth/login + validaciones & 3 & ALTA \\
        PBI-7 & Pantalla Login (frontend) & 3 & ALTA \\
        PBI-8 & RBAC middleware (CEO/Manager/Employee) & 5 & ALTA \\
        PBI-9 & Endpoint /auth/register (solo admin) & 2 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 2: Gestión de Usuarios (Sprint 2-3)}

\begin{table}[h]
    \centering
    \caption{Backlog: Usuarios y Sedes}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-10 & Endpoints CRUD usuarios (GET/POST/PUT/DELETE) & 5 & ALTA \\
        PBI-11 & Endpoints CRUD sedes & 3 & ALTA \\
        PBI-12 & Validaciones Zod (usuario, sede) & 2 & ALTA \\
        PBI-13 & Pantalla Admin: Crear usuario + asignar rol/sede & 5 & ALTA \\
        PBI-14 & Pantalla Admin: Listar usuarios, filtrar, editar & 5 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 3: Dashboard CEO (Sprint 3-4)}

\begin{table}[h]
    \centering
    \caption{Backlog: Dashboard Ejecutivo}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-15 & Endpoint GET /dashboard/metrics (ventas, ocupación, stock) & 8 & ALTA \\
        PBI-16 & Pantalla Dashboard: layout KPIs básico & 5 & ALTA \\
        PBI-17 & Gráficas Recharts (líneas, barras, tablas) & 5 & MEDIA \\
        PBI-18 & TanStack Query: caché de datos en frontend & 3 & MEDIA \\
        PBI-19 & Filtros por fecha y sede & 3 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 4: Gestión de Turnos (Sprint 3-5) - CORE}

\begin{table}[h]
    \centering
    \caption{Backlog: Turnos}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-20 & Endpoints CRUD turnos (crear, listar, cancelar) & 8 & ALTA \\
        PBI-21 & Validación overlaps + unit tests & 5 & ALTA \\
        PBI-22 & Endpoint confirmar turno (empleado) & 3 & ALTA \\
        PBI-23 & Calendario Gerente: semanal + crear turno & 8 & ALTA \\
        PBI-24 & Calendario Empleado: semanal/mensual & 5 & ALTA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 5: Permutas de Turnos (Sprint 5)}

\begin{table}[h]
    \centering
    \caption{Backlog: Solicitudes de Permuta}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-25 & Endpoint crear/listar ShiftRequest & 5 & MEDIA \\
        PBI-26 & Endpoint aprobar/rechazar permuta & 5 & MEDIA \\
        PBI-27 & Pantalla Gerente: Centro de Notificaciones & 5 & MEDIA \\
        PBI-28 & Pantalla Empleado: Solicitar permuta & 5 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 6: Inventario (Sprint 5-6)}

\begin{table}[h]
    \centering
    \caption{Backlog: Gestión de Productos}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-29 & Endpoints CRUD productos (crear, editar, listar) & 5 & MEDIA \\
        PBI-30 & Endpoint ajustar stock + log cambios & 5 & MEDIA \\
        PBI-31 & Alertas bajo stock (lógica backend) & 2 & MEDIA \\
        PBI-32 & Pantalla Gerente: Catálogo productos & 5 & MEDIA \\
        PBI-33 & Pantalla Gerente: Ajustar stock & 3 & MEDIA \\
        \bottomrule
    \end{tabularx}
\end{table}

\subsection*{Grupo 7: Nóminas (Sprint 6 - OPCIONAL)}

\begin{table}[h]
    \centering
    \caption{Backlog: Gestión de Nóminas}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-34 & Endpoint subir PDF nómina (validación básica) & 5 & BAJA \\
        PBI-35 & Endpoint listar nóminas empleado & 2 & BAJA \\
        PBI-36 & Pantalla Gerente: Subir nóminas & 3 & BAJA \\
        PBI-37 & Pantalla Empleado: Mis nóminas + descarga & 3 & BAJA \\
        \bottomrule
    \end{tabularx}
\end{table}


\subsection*{Grupo 8: Feedback y Testing (Sprint 6 - OPCIONAL)}

\begin{table}[h]
    \centering
    \caption{Backlog: Feedback y Testing}
    \vspace{0.3cm}
    \begin{tabularx}{\textwidth}{l l c l}
        \toprule
        \textbf{ID} & \textbf{Descripción} & \textbf{SP} & \textbf{Prioridad} \\
        \midrule
        PBI-38 & Endpoint feedback (crear, listar, cambiar estado) & 5 & BAJA \\
        PBI-39 & Pantalla Empleado: Formulario feedback & 2 & BAJA \\
        PBI-40 & Pantalla CEO: Tablero feedback & 3 & BAJA \\
        PBI-41 & Unit tests: 50+ tests, 80\% cobertura & 13 & BAJA \\
        PBI-42 & Integration tests: 5+ flujos críticos & 8 & BAJA \\
        \bottomrule
    \end{tabularx}
\end{table}

\section{Planificación de Sprints (6 x 2 semanas)}

\subsection*{Sprint 1 (Feb 9-22): Infraestructura y Autenticación}
\textbf{PBIs:} 1-9 (28 SP) \textbf{COMPLETADO}

El Sprint 1 constituye la fase fundamental del proyecto, estableciendo los cimientos arquitectónicos y sistemas de autenticación requeridos para el funcionamiento seguro de la aplicación. Este sprint se centró en la implementación de una infraestructura robusta que cumpliera con estándares industry e implementara buenas prácticas de seguridad.

\textbf{Diagrama de Entidades y Relaciones - Sprint 1:}

El schema de base de datos define cuatro entidades principales con las siguientes relaciones:
\begin{itemize}
    \item User pertenece a una Sede (opcional para ADMIN)
    \item User puede tener múltiples Shifts asignados
    \item Sede contiene múltiples Shifts
    \item ShiftRequest vincula dos Shifts (solicitante y destino) e involucra a dos usuarios (iniciador y destinatario)
\end{itemize}

Ver archivo de diagrama: \texttt{imagenes/diagramas/sprint1\_er.mmd} para visualización del modelo ER completo.

\subsubsection*{PBI-1: Setup (git, ESLint, Prettier)}

La inicialización del proyecto mediante control de versiones y definición de estándares de código es esencial para garantizar la mantenibilidad y colaboración eficiente \cite{typescript_docs}. Se realizó la configuración de:

\begin{itemize}
    \item \textbf{Gestor de Control de Versiones:} Repositorio Git en GitHub (TFG-Multihub) para tracking de cambios y colaboración
    \item \textbf{Linting:} ESLint con configuración \textit{airbnb-typescript} para mantener consistencia de código y prevenir errores comunes
    \item \textbf{Formateo:} Prettier configurado para garantizar formato automático coherente en todo el codebase
    \item \textbf{Estructura Monorepo:} Directorios separados para \texttt{/backend} y \texttt{/frontend} permitiendo gestión independiente de dependencias
\end{itemize}

\subsubsection*{PBI-2: PostgreSQL + Schema de Base de Datos}

El diseño relacional del sistema requería una base de datos que proporcionara ACID compliance. El schema incluye validaciones a nivel de base de datos (unique constraints) para prevenir datos inconsistentes. Por ejemplo, la tabla \textbf{Shift} tiene restricción única en (date, type, employeeId, sedeId) para evitar que un empleado sea asignado a dos turnos simultáneamente. Esta validación ocurre en la DB, no en código, asegurando integridad incluso si múltiples requests concurrentes intenten crear overlaps.

El schema relacional implementado define:

\begin{itemize}
    \item \textbf{User}: Con roles ADMIN (CEO), MANAGER (Gerente), EMPLOYEE (Empleado). Cada tabla tendrá foreign keys a usuarios para auditoría.
    \item \textbf{Sede}: Oficinas, cada una con un manager. Empleados pertenecen a una sede, managers solo ven su sede.
    \item \textbf{Shift}: Turnos asignados. La restricción única previene solapamientos automáticamente.
    \item \textbf{ShiftRequest}: Permutas solicitadas. Status progresa: PENDING a APPROVED/REJECTED.
\end{itemize}

Justificación de Negocio: Validar overlaps de turnos en código (aplicación) es frágil: si dos requests llegan simultáneamente, ambos ven ``no hay overlap'' y ambos insertan. La validación en DB es atómica y centralizada. Adem\u00e1s, si en el futuro agrego una API móvil, web scraper, o cambio framework, la lógica de validación sigue siendo correcta sin necesidad de replicarla.

\subsubsection*{PBI-3: Express.js + Middleware de Seguridad}

El backend actúa como punto único de autorización. Toda solicitud debe pasar por verificación de JWT y validación de rol antes de acceder a lógica de negocio. Esto centraliza decisiones de seguridad en un único lugar (principio DRY - Don't Repeat Yourself en seguridad).

\textbf{Justificación de Arquitectura:} Si autorizaciones estuvieran distribuidas (ej: validar rol en cada controlador), surgen problemas:
\begin{enumerate}
    \item \textbf{Inconsistencia}: Desarrollador olvida validar en una ruta, acceso no autorizado escapa.
    \item \textbf{Mantenimiento}: Si cambio políticas de rol (ej: ahora MANAGER puede ver reportes CEO), debo actualizar múltiples lugares.
    \item \textbf{Testing}: Imposible testear seguridad de manera centralizada.
\end{enumerate}

El middleware Express ejecuta antes de cualquier controlador:

\begin{lstlisting}[language=typescript]
app.use(authMiddleware);  // Todas las rutas post-auth deben ser autenticadas
app.use(corsMiddleware);  // CORS configurado ANTES de rutas
\end{lstlisting}

Una petición que no pase middleware nunca alcanza la lógica de negocio. Esto garantiza que es imposible olvidar validación.

\textbf{Justificación de CORS con Credenciales}: La arquitectura JWT + httpOnly cookies requiere credenciales habilitadas. Sin esto, el navegador rechaza las cookies incluso si el servidor las envía. Esta es una de las principales causas de bugs "authentication works in Postman but not in frontend".

\subsubsection*{PBI-4: Frontend con TypeScript Strict Mode}

La interfaz requería separación clara entre:
\begin{itemize}
    \item \textbf{Datos del Usuario Actual}: Email, nombre, rol. Nunca muda sin acción explícita.
    \item \textbf{Datos del Servidor}: Listados de turnos, empleados, sedes. Cambian frecuentemente, requieren refetch.
    \item \textbf{Estado Local de UI}: Formularios, dropdowns abiertos, loading spinners. Efímeros, no persisten.
\end{itemize}

\textbf{Justificación de TypeScript Strict Mode}: Errores comunes en JavaScript sin tipos:
\begin{enumerate}
    \item Acceder a propiedad inexistente: \texttt{user.sedeId.name} devuelve TypeError si sedeId es null
    \item Pasar tipo incorrecto a API: enviar email string cuando API espera number causa falla silenciosa en backend
    \item Renombrar campo en una ubicación pero olvidar otra: \texttt{user.email} vs \texttt{user.emailAddress}
\end{enumerate}

Con TypeScript strict mode:
\begin{itemize}
    \item \texttt{user.sedeId?.name} es syntactically obligatorio (optional chaining fuerza conciencia de nullability)
    \item Si cambio schema Zod, TypeScript obliga actualizar todo código que lo use
    \item Renombrar propiedades en interfaces causa compile errors automáticos
\end{itemize}

Costo: 10-15\\% más tiempo tipando inicialmente. Beneficio: 3-5x menos bugs en lógica compleja, debugging 10x más rápido (IDE proporciona autocompletion y type hints).\newline

\textbf{Justificación de Arquitectura React}: Las vistas comparten estado de autenticación (user, isAuthenticated, accessToken). Usar React Context evita "prop drilling" (pasar props a través de múltiples componentes). Alternativa: Redux/Zustand complican setup para una aplicación mediana.

\subsubsection*{PBI-5: JSON Web Tokens - Arquitectura de Dos Tokens}

La decisión de usar dos tokens (access + refresh) vs. un único token largo responde a trade-off seguridad vs. conveniencia:

\textbf{Escenario de Token Único (7 días):}
\begin{itemize}
    \item ✅ Usuario no necesita re-login frecuentemente (conveniente)
    \item ❌ Si token es robado, atacante tiene 7 días de acceso sin restricción
    \item ❌ No hay forma de revocar acceso (ej: empleado despedido sigue siendo autenticado por 7 días)
\end{itemize}

\textbf{Escenario de Dos Tokens (access=15m, refresh=7d):}
\begin{itemize}
    \item ✅ Access token corto limita daño de token robado (ventana de ataque 15m)
    \item ✅ Refresh token permite mantener sesión larga sin re-login (conveniente)
    \item ✅ Refresh token en httpOnly cookie: inaccesible a JavaScript (inmune a XSS)
    \item ✅ Server puede revocar refresh tokens inmediatamente (empleado despedido sale de sistema al acto)
\end{itemize}

Justificación: Tres tokens separados sería overkill. Refresh token en httpOnly cookie es estándar OAuth 2.0 \cite{oauth2_rfc} porque:
\begin{enumerate}
    \item JavaScript malicioso (XSS) no puede leerlo/robarlo
    \item Navegador lo incluye automáticamente en cookies (transparente para el código)
    \item Backend puede invalidar sesiones sin necesidad de client-side action
\end{enumerate}

Para comparación: sesiones tradicionales (server-side) requieren base de datos para cada validación (50ms+ lookup). JWT es stateless: validación criptográfica instantánea (<1ms), permite escalado horizontal sin sincronización.

\subsubsection*{PBI-6: Endpoint /auth/login - Flujo de Autenticación}

La validación de credenciales tiene varias capas defensivas encadenadas:

\begin{enumerate}
    \item \textbf{Validación de Esquema (Zod)}: Email debe ser válido, password mínimo 6 caracteres. Rechaza payloads inválidos.
    \item \textbf{Búsqueda de Usuario}: Si email no existe, no diferencia en mensaje de error (devuelve ``Usuario o contraseña incorrectos'' genérico). Esto previene enumeración de usuarios.
    \item \textbf{Comparación de Hash}: bcryptjs.compare() compara entrada con hash almacenado. Comparación es ``timing-safe'': toma el mismo tiempo independientemente de si password es correcto. Esto previene timing attacks donde atacante deduce caracteres correctos midiendo tiempo de respuesta.
    \item \textbf{Generación de Tokens}: Si todo es válido, genera JWT con claims (userId, role) y los retorna.
\end{enumerate}

\textbf{Diagrama de Secuencia - Flujo de Login:}

El flujo de autenticación puede visualizarse en el diagrama de secuencia disponible en \texttt{imagenes/diagramas/pbi6\_login\_sequence.mmd}. El diagrama muestra los controles de seguridad en cada etapa:
\begin{itemize}
    \item Validación de entrada (frontend y backend)
    \item Búsqueda segura de usuario en base de datos
    \item Comparación de contraseña con hash
    \item Generación y almacenamiento de tokens
    \item Redirección al dashboard con sesión establecida
\end{itemize}

\textbf{Por qué múltiples capas}: Si confiaría en una sola validación:
\begin{itemize}
    \item Solo schema: Un atacante envía HTML/JavaScript en password, causa RCE.
    \item Solo usuario encuentra: SQL injection, user enumeration.
    \item Comparación débil de passwords: Timing attacks, ataques de fuerza bruta.
\end{itemize}

Todo falla abierto: si cualquier capa falla, respuesta es ``no autenticado''.\newline

\textbf{Justificación de No Retornar Contraseña}: El JWT contiene email y rol del usuario (claims). Si retornara password en respuesta, y el JWT es interceptado, atacante tiene credenciales en texto plano. Aunque JWT está firmado (no encriptado), no debería contener datos sensibles.\newline

\textbf{Seguridad del Algoritmo bcryptjs}: bcryptjs es \textbf{adaptativo}: si computadoras se vuelven más rápidas, se incrementa cost factor (iterations) manualmente. Contrario a MD5/SHA1 que son obsoletos pero no se pueden volver más seguros sin cambiar algoritmo completamente.

\subsubsection*{PBI-7: Pantalla Login y Gestión de Estado Autenticado}

La arquitectura de manejo de autenticación en frontend enfrenta un trade-off:

\begin{itemize}
    \item \textbf{Estado Global (Context API):} Acceso desde cualquier componente, centralizado. Pero requiere provider wrapper, tiene ciclos de vida complejos.
    \item \textbf{Props Drilling:} Pasar state a través de componentes intermedios. Simple pero requiere encadenar: App - Navbar - UserMenu - LogoutButton, es tedioso.
    \item \textbf{State Manager Externo (Redux, Zustand):} Completo pero overhead para aplicación mediana.
\end{itemize}

\textbf{Decisión}: React Context API. Justificación: Solo 3-4 datos críticos (user, isAuthenticated, accessToken) son globales. El costo de Context es justificable.\newline

\textbf{Almacenamiento Asimétrico de Tokens}:
\begin{itemize}
    \item \textbf{Access Token en localStorage}: JavaScript puede leerlo para incluir en headers de API (\texttt{Authorization: Bearer <token>})
    \item \textbf{Refresh Token en httpOnly Cookie}: Navegador la maneja autom\u00e1ticamente, JavaScript no puede acceder (immune a XSS)
\end{itemize}

Este patrón es estándar en OAuth 2.0. Alternativa de guardar ambos en localStorage es m\u00e1s simple pero vulnerable: si XSS ocurre, atacante roba ambos tokens y la sesi\u00f3n es completamente comprometida.\newline

\textbf{Ciclo de Verificaci\u00f3n en App Startup}:
\begin{enumerate}
    \item Usuario abre aplicaci\u00f3n en navegador.
    \item AuthProvider monta, intenta refetch usando refresh token en cookie.
    \item Si refresh es válido, obtiene nuevo access token y usuario redirigido a dashboard (sesión persistió).
    \item Si refresh expiró, usuario redirigido a login page (sesión finalizó).
\end{enumerate}

Esto permite cerrar navegador/perder tab y seguir autenticado (UX mejorada), pero también permite la revocación de sesiones en servidor (logout realmente termina sesión global).

\subsubsection*{PBI-8: Control de Acceso Basado en Roles (RBAC)}

El sistema tiene tres roles con permisos progresivos:

\begin{itemize}
    \item \textbf{ADMIN (CEO)}: Acceso total. Crear usuarios, cambiar roles, ver reportes globales.
    \item \textbf{MANAGER (Gerente)}: Acceso limitado a su sede. Ver empleados de su sede, crear/cancelar turnos en su sede, ver nóminas agregadas de su sede.
    \item \textbf{EMPLOYEE (Empleado)}: Acceso restringido a sí mismo. Ver sus turnos, sus nóminas, solicitar permutas.
\end{itemize}

\textbf{Principio de Menor Privilegio (Least Privilege)}: Cada usuario tiene exactamente los permisos necesarios, no más. Esto limita daño si credenciales son comprometidas.\newline

\textbf{Arquitectura de Validación en Dos Puntos}:
\begin{enumerate}
    \item \textbf{Middleware}: Valida presencia y validez de JWT. Si fail, rechaza petición inmediatamente sin alcanzar lógica de negocio.
    \item \textbf{Nivel de Base de Datos}: Queries están filtradas por rol. Ejemplo: Empleado A con query \texttt{SELECT * FROM Shifts WHERE employeeId = A.id}. Incluso si código middleware falla, empleado A no puede acceder a turnos de empleado B (garantizado a nivel SQL).
\end{enumerate}

\textbf{Validación de Pertenencia de Recurso}: Cuando empleado A intenta ver su nómina, el código verifica \texttt{if (nómina.userId !== req.user.userId) then reject}. Esto previene race conditions donde roles fueron cambiados después de autenticaci\u00f3n pero antes de consulta.\newline

\textbf{Por qué dos puntos de validaci\u00f3n}:
\begin{itemize}
    \item Si solo middleware: Cambios en roles después de autenticación pueden ser explotados.
    \item Si solo DB: Un cambio en c\u00f3digo de query puede exponer datos (riesgo humano).
    \item Ambos: Defense in depth. Un fallo no compromete seguridad.
\end{itemize}
\textbf{Diagrama de Secuencia - Validación RBAC:}

El proceso de validación de roles en cada petición se visualiza en el diagrama disponible en \texttt{imagenes/diagramas/pbi8\_rbac\_sequence.mmd}. El flujo muestra:
\begin{itemize}
    \item Cliente envía petición con JWT en header Authorization
    \item Middleware valida token, extrae claims (incluyendo role)
    \item RoleMiddleware rechaza si role no está en lista permitida
    \item Controller ejecuta lógica con filtrado de datos según rol
    \item Base de datos asegura que resultados están filtrados (defensa en profundidad)
    \item Cliente recibe solo datos para los que está autorizado
\end{itemize}
\subsubsection*{PBI-9: Endpoint /auth/register - Creación de Usuarios por Admin}

La creación de usuarios sigue un flujo específico para garantizar control y auditabilidad:

\textbf{Flujo}:
\begin{enumerate}
    \item Admin (CEO/HR) proporciona: email, nombre, rol, sede (opcional para ADMIN).
    \item Sistema genera contraseña temporal de 10 caracteres aleatorios.
    \item Sistema crea usuario en DB con contraseña hasheada (bcryptjs 10 rounds).
    \item Admin recibe contraseña temporal y la comunica al empleado (por email, fuera de band, etc.).
    \item Empleado loguea con email + temp password.
    \item Sistema detecta ``es su primer login'' (flag en DB o contraseña en estado ``temporary'') y obliga cambio de contraseña.
    \item Empleado proporciona: old\_password (la temp) + new\_password (su contraseña real).
    \item Sistema valida old\_password contra hash, si valida hasheada new\_password.
\end{enumerate}

\textbf{Justificación de Contraseña Temporal}:
\begin{itemize}
    \item (PRO) Admin no conoce contraseña real del empleado (segregación de deberes)
    \item (PRO) Empleado no puede elegir contraseña débil (temp es robusta por defecto)
    \item (PRO) Previene ataques de diccionario (contraseña random de 10 chars tiene $10^{10}$ combinaciones vs human-chosen típicamente 3 palabras)
    \item (CONTRA) Requiere que admin comunique temp password (fuera de band). Riesgo si interceptado.
\end{itemize}

\textbf{Alternativa Rechazada}: Admin elige contraseña inicial.
\begin{itemize}
    \item (PRO) Menos pasos
    \item (CONTRA) Admin podría espiar contraseña del empleado (desconfianza)
    \item (CONTRA) Contraseña podría ser débil, predecible
\end{itemize}

\textbf{Validación de Cambio de Contraseña}: El endpoint \texttt{POST /auth/change-password} requiere:
\begin{itemize}
    \item \texttt{oldPassword}: Hasheado en DB, comparado contra entrada. Previene que usuario A cambie password de usuario B.
    \item \texttt{newPassword}: Validado por Zod (mínimo 6 caracteres, no puede ser igual a oldPassword).
\end{itemize}

\textbf{Auditoría}: Cada cambio de contraseña registra timestamp, IP, user agent. Crítico para investigar si una contraseña fue cambiada sin consentimiento.

\subsubsection*{Componente ProtectedRoute - Rutas Protegidas (Frontend)}

Frontend tiene dos niveles defensivos:

\begin{enumerate}
    \item \textbf{Nivel de Componente (ProtectedRoute)}: Si el usuario no está autenticado, redirige a login. Si está autenticado pero su rol no está en lista de roles requeridos, muestra ``Acceso denegado''.
    \item \textbf{Nivel de API}: Incluso si ProtectedRoute falla (ej: bug de desarrollo), el backend valida JWT y rechaza requests no autorizadas.
\end{enumerate}

\textbf{Arquitectura de Capas}:
\begin{itemize}
    \item Backend es ``la verdad''. Es la única fuente auténtica de permiso.
    \item Frontend es UX layer. Protege la UI para que la interfaz no se rompa o no muestre opciones invalidas.
\end{itemize}

Nunca confiar en frontend para seguridad. El atacante puede abrir DevTools, falsificar localStorage, enviar requests sin pasar por UI.\newline

\textbf{Redirección a Login}:
\begin{lstlisting}[language=typescript]
if (!isAuthenticated) {
  return <Navigate to="/login" replace />;
}
\end{lstlisting}

La redirección es el comportamiento correcto porque:
\begin{itemize}
    \item Sessión expiró: Usuario intenta acceder /dashboard, redirige a login
    \item XSS attack: Si localStorage fue limpiada por ataques, usuario es deslogeado automáticamente
    \item Browser cerrado: Refresh token expiró (7 días pasó), redirige a login
\end{itemize}

Alternativa: la princiapl alternativa es la de mostrar un error. Pero la UX es peor (usuario confundido), y el login no es un ''error'', es un estado normal.

\subsubsection*{Resumen de Decisiones Arquitectónicas en Sprint 1}

Las decisiones clave que definen la arquitectura del sistema:

\begin{enumerate}
    \item \textbf{Validaciones a Nivel de DB}: Constraints de unique, foreign keys. Garantiza integridad incluso si código tiene bugs. Costo mínimo (DDL) beneficio máximo (inmutable).
    
    \item \textbf{Middleware Centralizad de Seguridad}: Imposible que desarrollador olvide validar JWT si es middleware global. ``Fail by default'' (rechaza si no authorized).
    
    \item \textbf{TypeScript Strict}: Costo inicial 10-15\\% más tiempo tipando. Beneficio: 80\\% menos bugs en lógica compleja post-launch (multiplicador en mantenimiento).
    
    \item \textbf{Dos Tokens}: Acceso corto + Refresh largo. Balanceado seguridad (ventana de riesgo limitada) vs UX (no re-login constantemente).
    
    \item \textbf{Contraseña Temporal}: Admin no conoce password real. Empleado es forzado a elegir password propia. Implica extra paso pero gana confianza, auditoría.
    
    \item \textbf{Capas de Validación}: Frontend para UX, Backend para seguridad. Frontend puede romperse (attacker), backend no.
    
    \item \textbf{RBAC Granular}: Roles separados (ADMIN/MANAGER/EMPLOYEE) con permisos progresivos. Escalable: agregar nuevo rol es line-deletion-no code change.
\end{enumerate}

Cada decisión responde a un requisito de negocio o arquitectónico específico, no es cargo-culting de ``best practices`.

\subsubsection*{Resultados y Validación Sprint 1}

La completitud del Sprint 1 fue validada mediante:

\begin{itemize}
    \item \textbf{Pruebas Funcionales}: Endpoint \texttt{/api/auth/login} responde correctamente con JWT tokens válidos y user data
    \item \textbf{Verificación de Seguridad}: Validación de httpOnly cookies para refresh tokens y CORS configuration correcta
    \item \textbf{Cobertura de Tipado}: TypeScript strict mode sin errores de compilación en frontend y backend
    \item \textbf{Infraestructura}: Docker Compose services (PostgreSQL, Backend, Frontend) todos operacionales
    \item \textbf{Datos de Prueba}: Database seeded con usuarios de prueba en todos los roles (ADMIN, MANAGER, EMPLOYEE)
    \item \textbf{Endpoints API}: 7 endpoints de autenticación completamente funcionales
\end{itemize}

\textbf{Flujo de autenticación end-to-end validado:}
\begin{enumerate}
    \item Usuario navega a \texttt{http://localhost:3000/login}
    \item Ingresa credenciales que son validadas por esquema Zod contra restricciones definidas
    \item Submit realiza POST request hacia \texttt{/api/auth/login} con credenciales JSON
    \item Backend localiza usuario por email en PostgreSQL y valida contraseña contra hash bcryptjs
    \item JWT tokens generados con claims (userId, email, role) y expiración configurada
    \item Access token retornado en respuesta JSON; refresh token en httpOnly cookie
    \item Frontend almacena accessToken en localStorage para futuras requests API
    \item User automáticamente redirigido a dashboard con sesión activa y user info en contexto
    \item Logs de auditoría registran acceso exitoso (timestamp, IP, user agent)
    \item Logout limpia localStorage y elimina refresh cookie vía Set-Cookie header
    \item Subsequent requests usan accessToken en Authorization header (Bearer scheme)
\end{enumerate}

\subsubsection*{Decisiones de Arquitectura Fundamentales}

Las decisiones técnicas en Sprint 1 fueron justificadas por:

\begin{itemize}
    \item \textbf{JWT sobre Session Storage}: Stateless authentication facilita escalabilidad horizontal en microservicios futuros \cite{rfc7519}
    \item \textbf{Dual Token Strategy}: Access tokens cortos (15m) reduce ventana de riesgo; refresh tokens largos (7d) mantienen UX
    \item \textbf{httpOnly Cookies}: Previene XSS attacks eliminando acceso JavaScript a refresh tokens críticos
    \item \textbf{Contrast-time Password Comparison}: Uso de bcryptjs.compare() previene timing attacks en validación de credenciales
    \item \textbf{Role-Based Access Control}: Implementación granular permite asignación flexible de permisos con política centralizada
    \item \textbf{TypeScript Strict Mode}: Elimina categorías enteras de bugs comunes (null/undefined, implicit any types)
    \item \textbf{Prisma ORM}: Schema como source of truth; migraciones versionadas permiten auditoría histórica de cambios DB
\end{itemize}

\subsection*{Sprint 2 (Feb 23-Mar 8): RBAC y Gestión de Usuarios}
\textbf{PBIs:} 8-14 (30 SP)

\subsection*{Sprint 3 (Mar 9-22): Gestión de Turnos}
\textbf{PBIs:} 20-24 (28 SP)

\subsection*{Sprint 4 (Mar 23-Apr 5): Dashboard CEO}
\textbf{PBIs:} 15-19 (26 SP)

\subsection*{Sprint 5 (Apr 6-19): Permutas + Inventario}
\textbf{PBIs:} 25-33 (30 SP)

\subsection*{Sprint 6 (Apr 20-May 4): Nóminas, Feedback y Testing}
\textbf{PBIs:} 34-42 (30 SP)

